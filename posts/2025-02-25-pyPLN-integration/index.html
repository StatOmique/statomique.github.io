<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="">

<title>Analyse de données de comptage multivariées et intégration de données omiques – StatOmique</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-b758ccaa5987ceb1b75504551e579abf.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-960d9d362f81d399278ec3e29b622b37.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-e7f4145358ce1d0cd37d8d374dbb44f9.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-960d9d362f81d399278ec3e29b622b37.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Pas de résultats",
    "search-matching-documents-text": "documents trouvés",
    "search-copy-link-title": "Copier le lien vers la recherche",
    "search-hide-matches-text": "Cacher les correspondances additionnelles",
    "search-more-match-text": "correspondance de plus dans ce document",
    "search-more-matches-text": "correspondances de plus dans ce document",
    "search-clear-button-title": "Effacer",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Annuler",
    "search-submit-button-title": "Envoyer",
    "search-label": "Recherche"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../media/LOGO-GDR_BIMMM.png" alt="" class="navbar-logo light-content">
    <img src="../../media/LOGO-GDR_BIMMM.png" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">StatOmique</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Recherche"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Basculer la navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Accueil</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../animations.html"> 
<span class="menu-text">Animations</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../communaute.html"> 
<span class="menu-text">Communauté</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../communications.html"> 
<span class="menu-text">Communications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../apropos.html"> 
<span class="menu-text">Organisation</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Basculer le mode sombre"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Analyse de données de comptage multivariées et intégration de données omiques</h1>
            <p class="subtitle lead">pyPLNmodels, idiffomix, …</p>
                                <div class="quarto-categories">
                <div class="quarto-category">workshop</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Date de publication</div>
      <div class="quarto-title-meta-contents">
        <p class="date">11 mars 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sur cette page</h2>
   
  <ul>
  <li><a href="#program" id="toc-program" class="nav-link active" data-scroll-target="#program">Program</a></li>
  <li><a href="#morning" id="toc-morning" class="nav-link" data-scroll-target="#morning">Morning</a></li>
  <li><a href="#afternoon" id="toc-afternoon" class="nav-link" data-scroll-target="#afternoon">Afternoon</a></li>
  <li><a href="#informations-pratiques" id="toc-informations-pratiques" class="nav-link" data-scroll-target="#informations-pratiques">Informations pratiques</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">






<section id="program" class="level2">
<h2 class="anchored" data-anchor-id="program">Program</h2>
</section>
<section id="morning" class="level2">
<h2 class="anchored" data-anchor-id="morning">Morning</h2>
<ul>
<li><p><strong>9h30-10h00</strong> Accueil - café</p></li>
<li><p><strong>10h00-10h15</strong> Opening presentation</p></li>
<li><p><strong>10h15-11h</strong> <img src="../../media/2025-02-25/batardierebastien.jpg" class="img-fluid" width="100"> <a href="https://bastien-mva.github.io/">Bastien Batardière</a>, INRAE, AgroParisTech, MIA-Paris-Saclay, <strong><code>{pyPLNmodels}</code>: A Python package to analyze multivariate high-dimensional count data</strong></p></li>
</ul>
<p><code>{pyPLNmodels}</code> est une bibliothèque Python pour l’analyse de données de comptage multivariées à l’aide du modèle Poisson Lognormal (PLN) et ses variantes. Conçue pour traiter de grands jeux de données, elle permet d’extraire des informations clés à partir de données complexes. Elle est particulièrement adaptée à l’analyse des données RNA-seq, en normalisant les comptes et en identifiant les relations entre gènes.</p>
<p>Fonctionnalités principales: Elle propose une modélisation avancée des données de comptage, l’estimation des paramètres clés tels que les coefficients de régression et la covariance, ainsi que la normalisation des données pour une meilleure interprétation. L’analyse des corrélations et des poids des covariables est également intégrée, avec une capacité d’adaptation aux données de grande dimension.</p>
<p>Modèles implémentés: PLN est le modèle de base pour l’analyse des données de comptage. PlnPCA permet une réduction de dimension via l’ACP probabiliste adaptée aux données de comptage. ZIPln prend en compte l’inflation de zéros pour mieux modéliser des données comportant de nombreuses valeurs nulles.</p>
<p>Le site web: <a href="https://pypi.org/project/pyPLNmodels/" class="uri">https://pypi.org/project/pyPLNmodels/</a> et les <a href="https://github.com/PLN-team/slideshow/tree/main/talks/statomique_202503_pypln/public">slides</a>.</p>
<ul>
<li><strong>11h00-11h20</strong> El Hacene DJAOUT, LPSM, Sorbonne Université, France, <strong><code>{VaRaPS}</code> : Un package Python pour l’estimation des proportions de variants SARS-CoV-2 à partir de données de séquençage groupées</strong></li>
</ul>
<p>L’épidémiologie basée sur les eaux usées s’est révélée être un outil puissant pour la surveillance des variants du SARS-CoV-2. Nous présentons <code>{VaRaPS}</code> (Variants Ratios from Pooled Sequencing), un package Python qui optimise les algorithmes statistiques fondamentaux pour estimer efficacement les proportions de lignées SARS-CoV-2 à partir de données de séquençage groupées d’eaux usées. <code>{VaRaPS}</code> intègre un algorithme personnalisé d’identification des variants, spécialement conçu pour les données de séquençage groupées, exploitant les informations de mutations au niveau des lectures et utilisant des représentations matricielles creuses pour une gestion efficace des données.</p>
<p><code>{VaRaPS}</code> améliore considérablement l’efficacité computationnelle des méthodes existantes (Freyja, LCS et VirPool), atteignant des facteurs d’accélération jusqu’à 3 570 fois pour les temps d’optimisation et 103 fois pour l’extraction des données, tout en maintenant ou améliorant la précision des estimations. Le package intègre un paramètre de taux d’erreur pour prendre en compte les erreurs de séquençage, affinant davantage la précision statistique. Les analyses comparatives utilisant des jeux de données synthétiques démontrent la performance supérieure de VaRaPS dans l’estimation de la prévalence des lignées, avec une précision et une cohérence améliorées pour toutes les méthodes implémentées.</p>
<p>L’architecture modulaire et la conception orientée utilisateur du package facilitent son application dans des contextes réels. <code>{VaRaPS}</code> représente une avancée significative dans les outils bioinformatiques et biostatistiques pour l’analyse des lignées virales, offrant une solution robuste et efficace pour l’épidémiologie basée sur les eaux usées dans l’ère post-pandémique.</p>
<ul>
<li><strong>11h20-11h40</strong> Maximilien Colange, Abdelkader Behdenna, Epigene Labs, France, <strong>Bridging the Gap Between R and Python in Bulk Transcriptomic Data Analysis with InMoose</strong></li>
</ul>
<p>We introduce <code>{InMoose}</code>, an open-source Python environment for omic data analysis. Due to its wide adoption, Python has grown as a de facto standard in fields increasingly important for bioinformatic pipelines, such as data science, machine learning, or AI. As a general-purpose language, Python is also recognized for its versatility and scalability. InMoose aims at bringing state-of-the-art tools, historically written in R, to the Python ecosystem. Our intent is to provide a drop-in replacement for R tools, so our approach focuses on the faithfulness to the original tools outcomes. The first development phase has focused on bulk transcriptomic data, with current capabilities encompassing data simulation, batch effect correction, and differential analysis and meta-analysis. <code>{InMoose}</code> offers a Python implementation of several state-of-the-art tools originally written in R: <code>{ComBat}</code> and <code>{ComBat-Seq}</code> (batch effect correction), <code>{edgeR}</code>, <code>{DESeq2}</code>, <code>{limma}</code> (differential gene expression analysis), <code>{splatter}</code> (RNA-Seq data simulation).</p>
<p>To our knowledge, <code>{InMoose}</code> is the sole Python implementation of <code>{ComBat-Seq}</code>, <code>{edgeR}</code> and <code>{limma}</code>. <code>{InMoose}</code> also offers original features: a quality control report for cohorts built through the batch effect correction features; a differential gene expression meta-analysis module.</p>
<p>We compare <code>{InMoose}</code> with the R original implementations and alternative Python implementations when available. Our experiments show that the results of InMoose are very similar, if not identical, to those of the original R tools. This positions <code>{InMoose}</code> as a key tool to bridge R and Python ecosystem and to ensure reproducibility and comparability between R-based and Python-based bioinformatics pipelines.</p>
<p>Slides : <a href="../../media/2025-02-25/StatOmique_Colange_InMoose.pdf">here</a><br>
Package : <a href="https://github.com/epigenelabs/inmoose" class="uri">https://github.com/epigenelabs/inmoose</a><br>
References :<br>
Behdenna, A., Colange, M., Haziza, J. et al.&nbsp;pyComBat, a Python tool for batch effects correction in high-throughput molecular data using empirical Bayes methods. <em>BMC Bioinformatics</em> 24, 459 (2023). <a href="https://doi.org/10.1186/s12859-023-05578-5" class="uri">https://doi.org/10.1186/s12859-023-05578-5</a><br>
Colange, M., Appé, G., Meunier, L. et al.&nbsp;Bulk Transcriptomic Analysis with InMoose, the Integrated Multi-Omic Open-Source Environment in Python. <em>Bioarxiv 2024.11.29.625982</em> (2024). <a href="https://doi.org/10.1101/2024.11.29.625982" class="uri">https://doi.org/10.1101/2024.11.29.625982</a><br>
Colange, M., Appé, G., Meunier, L. et al.&nbsp;Differential Expression Analysis with InMoose, the Integrated Multi-Omic Open-Source Environment in Python. <em>Bioarxiv 2024.11.14.623578</em> (2024). <a href="https://doi.org/10.1101/2024.11.14.623578" class="uri">https://doi.org/10.1101/2024.11.14.623578</a><br>
</p>
<ul>
<li><p><strong>11h40-12h30</strong> <em>Work and feedback around methylation</em></p></li>
<li><p><strong>11h40-12h00</strong> Valentin Costes, Eliance, <strong>Microarray vs NGS</strong></p></li>
</ul>
<p>Chez le bovin, la méthylation de l’ADN pourrait potentiellement être utilisée pour prédire des phénotypes. Il existe plusieurs technologies permettant d’analyser cette dernière, chacune ayant certains points forts et des points faibles. Parmi celle-ci, l’équipe utiliser principalement des méthodes de séquençages par RRBS, et depuis peu des données obtenues par Micro-array. L’objectif de la présentation sera de présenter les types de données qui sont générées, et de montrer quelques comparaisons entre des données produites par séquençages ou par Micro-array.</p>
<ul>
<li><strong>12h00-12h15</strong> Luc Jouneau, VIM, BREED, INRAE, Jouy-en-Josas, <strong>Application of <code>{edgeR}</code> package to the analysis of RRBS methylation data</strong></li>
</ul>
<p>En 20xx, dans un post sur un forum, Gordon Smyth montre qu’il est possible d’utiliser <code>{edgeR}</code> pour l’analyse de données RRBS. Depuis, son équipe a publié <a href="https://f1000research.com/articles/6-2055/v2">un article à ce sujet</a> et a même intégré ce cas d’étude dans la <a href="https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf">documentation et les fonctions de son package, section 4.8</a>. En pratique, quelles sont les atouts et inconvénients de l’application de <code>{edgeR}</code> sur ce type de données&nbsp;?</p>
<ul>
<li><strong>12h15-12h30</strong> Anne Frambourg, VIM, BREED, INRAE, Jouy-en-Josas, <strong>Evaluation des résultats sur une analyse à 2 facteurs avec le package <code>{DSS}</code></strong></li>
</ul>
<p>Application de la méthode Dispersion Shrinkage for Sequencing data (DSS, Park and Wu, 2016), fondée sur un modèle beta-binomial, dans le cadre du projet BoSexDim qui a pour ambition entre autres d’identifier les dimorphismes sexuels précoces chez l’embryon de bovin et d’étudier comment ces dimorphismes sont modifiés en réponse à l’environnement embryonnaire (vitro/vivo). Plusieurs modèles ont été considérés pour l’analyse à deux facteurs sexe et milieu. Un effet d’interaction entre les deux effets ayant été identifié, le modèle avec variables concaténées sexe:milieu a été retenu car il permet de réaliser toutes les analyses différentielles entre chaque sous-catégorie (Femelle – Vivo, Femelle – Vitro, Mâle – Vivo, Mâle – Vitro).</p>
<ul>
<li><strong>12h30 - 14h00</strong> <strong>Lunch break</strong></li>
</ul>
</section>
<section id="afternoon" class="level2">
<h2 class="anchored" data-anchor-id="afternoon">Afternoon</h2>
<div class="callout callout-style-simple callout-warning">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Afternoon presentations will be in english.</p>
</div>
</div>
</div>
<ul>
<li><strong>14h00 - 14h50</strong> <img src="../../media/2025-02-25/clairegormley.png" class="img-fluid" width="100"> <a href="http://www.maths.ucd.ie/~cgormley">Claire Gormley</a>, Professor, School of Mathetmathics and Statistics, University College Dublin, <strong>Integrated differential analysis of multi-omics data using a joint mixture model: idiffomix</strong></li>
</ul>
<p>Koyel Majumdar, Florence Jaffrézic, Andrea Rau, <strong>Isobel Claire Gormley</strong>, Thomas Brendan Murphy</p>
<p>Gene expression and DNA methylation are two interconnected biological processes and understanding their relationship is important in advancing understanding in diverse areas, including disease pathogenesis, environmental adaptation, developmental biology, and therapeutic responses. Differential analysis, including the identification of differentially methylated cytosine-guanine dinucleotide (CpG) sites (DMCs) and differentially expressed genes (DEGs) between two conditions, such as healthy and affected samples, can aid understanding of biological processes and disease progression. Typically, gene expression and DNA methylation data are analysed independently to identify DMCs and DEGs which are further analysed to explore relationships between them. Such approaches ignore the inherent dependencies and biological structure within these related data.</p>
<p>A joint mixture model is proposed that integrates information from the two data types at the modelling stage to capture their inherent dependency structure, enabling simultaneous identification of DMCs and DEGs. The model leverages a joint likelihood function that accounts for the nested structure in the data, with parameter estimation performed using an expectation-maximisation algorithm.</p>
<p>Performance of the proposed method, <code>{idiffomix}</code>, is assessed through a thorough simulation study and application to a publicly available breast cancer dataset. Several genes, identified as non-differentially expressed when the data types were modelled independently, had high likelihood of being differentially expressed when associated methylation data were integrated into the analysis. The idiffomix approach highlights the advantage of an integrated analysis via a joint mixture model over independent analyses of the two data types; genome-wide and cross-omics information is simultaneously utilised providing a more comprehensive view.</p>
<p>Slides : <a href="../../media/2025-02-25/StatOmique_Gormsley_idiffomix.pdf">here</a><br>
Preprint : <a href="https://doi.org/10.48550/arXiv.2412.17511" class="uri">https://doi.org/10.48550/arXiv.2412.17511</a><br>
R package : <a href="https://cran.r-project.org/package=idiffomix" class="uri">https://cran.r-project.org/package=idiffomix</a></p>
<ul>
<li><strong>14h50 - 15h10</strong> Ekaterina Tomilina, MaIAGE (Dynenvie) and GABI (Gibbs), INRAE, Jouy-en-Josas, <strong>Likelihood-based partial correlation Gaussian copula network inference for heterogeneous multi-omics data</strong></li>
</ul>
<p>Large-scale heterogeneous data integration for network inference is a key methodological challenge, especially in the context of multi-omic data analysis. The heterogeneous nature can be handled by assuming a Gaussian copula model, where the biological network can be assimilated to the partial correlations of a latent Gaussian vector. The estimation of the corresponding precision matrix is realized by combining the graphical Lasso (Friedman et al., 2007) with a semi-parametric pairwise estimation of the copula correlation matrix (Tomilina et al., 2024). We present a simulation study by comparing the performance of the method above against a moment-based approach (Zhang et al., 2021). Then, we show promising application results on an ICGC data set related to breast cancer in the US.</p>
<p>References :<br>
<strong>Sparse inverse covariance estimation with the graphical lasso</strong>, Friedman, J. and Hastie T. and Tibshirani, R., 2007, <em>Biostatistics vol.&nbsp;9 no.3 pp 432-441</em>.<br>
<strong>A latent gaussian copula model for mixed data analysis in brain imaging genetics</strong>, Zhang, A. et al, 2021, <em>IEEE Computer Society Press vol.&nbsp;18 no.4 pp 1350-1360</em>.<br>
<strong>A semi-parametric Gaussian copula model for heterogeneous network inference: an application to multi-omics data</strong>, Tomilina, E. and Mazo, G. and Jaffrezic, F., 2024, <a href="https://hal.inrae.fr/hal-04847648" class="uri">https://hal.inrae.fr/hal-04847648</a></p>
<ul>
<li><strong>15h10 - 15h30</strong> Yanis Asloudj, LaBRI, Univ. Bordeaux, <strong><code>{fEVE}</code>, a modular framework for ensemble clustering in -omics data science, and more.</strong></li>
</ul>
<p>In the era of big data analytics and personalized medicine, clustering analyses have become a cornerstone of -omics bioinformatics. Shortly, clustering analyses attempt to classify several entities into fewer homogeneous groups, by leveraging a set of measurements taken from these entities. For instance, in bulk oncology transcriptomics, clustering analyses are frequently conducted to identify groups (or «&nbsp;clusters&nbsp;») of patients, inflicted with similar cancer subtypes, according to the gene expression measured in their tumor. Because of their importance in data science as a whole, numerous clustering algorithms have been developed since the last century. In the field of single-cell transcriptomics (or «&nbsp;scRNA-seq&nbsp;») only, more than 300 algorithms have been developed already. Because each of these algorithms exploits different aspects of the data, the clusters they predict can vary drastically.</p>
<p>To ensure that the results of a clustering analysis were robust to the algorithm used, ensemble clustering methods were developed. Succinctly, these methods applied multiple clustering algorithms on the same dataset, and they integrated the results of each algorithm so as to generate a single robust prediction of clusters.</p>
<p>In a previous work, we had developed our own scRNA-seq ensemble clustering algorithm, named <code>{scEVE}</code>. Unlike state-of-the-art algorithms, <code>{scEVE}</code> was able to address two main conceptual challenges in clustering&nbsp;: it was able (1) to quantify the uncertainty of its predictions, and (2) to generate clustering results with multiple resolutions. To do so, our algorithm first applied multiple scRNA-seq clustering methods on a dataset to predict a large pool of base clusters. From this pool, robust clusters (i.e.&nbsp;clusters predicted by multiple methods) were predicted, and their robustness was quantified by using basic properties from graph and set theories. Finally, these robust clusters were biologically characterized, and this procedure was repeated recursively on every characterized cluster – so long as the robustness of the analysis kept improving.</p>
<p>While some steps of our algorithm were specific to scRNA-seq measurements – namely, the prediction of base clusters, and the biological characterization of robust clusters – we believed that the main contributions of <code>{scEVE}</code> (i.e.&nbsp;the robustness quantification and the multi-resolution recursive clustering) were valuable for any type of clustering problem. Thus, to facilitate the utilization of these contributions, we have now developed the <code>{fEVE}</code> framework, which we have implemented in an R package available on Github.</p>
<p>Briefly, the <code>{fEVE}</code> framework is a modular ensemble clustering framework, that allows developers to easily replace the single-cell specific functions we have set prior to (and after) the identification of robust clusters. By replacing these functions with ones developed for bulk transcriptomics data (for example), one can easily conduct a bulk RNA-seq clustering analysis with uncertainty values and multiple resolutions. Consequently, we expect that any data scientist interested in clustering will benefit from the modularity our framework.</p>
<p>As of today, we have two research perspectives ourselves, that capitalize on this novel clustering framework. First, we plan on measuring the effects of individual framework components (e.g.&nbsp;the methods used to predict base clusters) on clustering results. Secondly, we would like to investigate the usefulness of our framework in answering more diverse biological problems (e.g.&nbsp;multi-omics analyses).</p>
<p>Slides : <a href="../../media/2025-02-25/StatOmique_Asloudj_feve.pdf">here</a><br>
Package : <a href="https://github.com/yanisaspic/fEVE" class="uri">https://github.com/yanisaspic/fEVE</a></p>
<ul>
<li><p><strong>15h30 - 16h00</strong> <strong>Coffee break</strong></p></li>
<li><p><strong>16h00 - 16h30</strong> <a href="https://mariechion.github.io/">Marie Chion</a>, University of Cambridge, <strong><code>{ProteoBayes}</code>: a Bayesian framework for differential proteomics analysis</strong></p></li>
</ul>
<p>This work introduces a Bayesian hierarchical model for mass spectrometry-based differential proteomics analysis, addressing missing values, peptide correlations and uncertainty quantification. Unlike existing approaches that rely on moderated variance estimates, <code>{ProteoBayes}</code> leverages conjugate priors to enable direct posterior sampling without costly MCMC methods. Applied to real proteomics data, it provides a more intuitive and comprehensive quantification of the uncertainty around peptide intensity differences.</p>
<p>Preprint : <a href="https://arxiv.org/abs/2307.08975" class="uri">https://arxiv.org/abs/2307.08975</a><br>
Package : <a href="https://mariechion.github.io/ProteoBayes/" class="uri">https://mariechion.github.io/ProteoBayes/</a></p>
<ul>
<li><strong>16h30 - 17h00</strong> <a href="https://www.maynoothuniversity.ie/faculty-science-engineering/our-people/szymon-urbas">Szymon Urbas</a>, Maynooth University, Ireland, <strong>Bayesian probabilistic partial least squares (BPLS)</strong></li>
</ul>
<p>I will introduce a statistical model that emulates the desirable properties of partial least squares regression whilst enabling principled uncertainty quantification, and which allows for various model-based modifications. The model can be used in univariate and multivariate regression/prediction problems involving high-dimensional sets of covariates. The model is implemented in the R package <code>{bplsr}</code> available on CRAN.</p>
<p>Slides : <a href="../../media/2025-02-25/StatOmique_Urbaz_bpls.pdf">here</a><br>
Paper : <a href="https://doi.org/10.1214/24-AOAS1947" class="uri">https://doi.org/10.1214/24-AOAS1947</a><br>
Package : <a href="https://cran.r-project.org/package=bplsr" class="uri">https://cran.r-project.org/package=bplsr</a></p>
<ul>
<li><strong>17h00 - 17h15</strong> Closing</li>
</ul>
</section>
<section id="informations-pratiques" class="level2">
<h2 class="anchored" data-anchor-id="informations-pratiques">Informations pratiques</h2>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Date</strong> : <strong>Mardi 11 mars de 9h30 à 17h15</strong></p>
<p><strong>Venue</strong> : <a href="https://www.agroparistech.fr/en/visiting-our-school">Campus Agro Paris Saclay, Palaiseau, France</a></p>
<p>L’accès sur site sera réservé aux personnes inscrites.</p>
</div>
</div>
</div>
<iframe src="https://mapcarta.com/fr/W643701088/Carte" width="300" height="225" style="border:0;" allowfullscreen="" loading="lazy" referrerpolicy="no-referrer-when-downgrade">
</iframe>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copié");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copié");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/StatOmique\.github\.io\/statomique\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>